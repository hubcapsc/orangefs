/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-types.h"
#include "pvfs2-internal.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-eattr.h"
#include "pint-security.h"
#include "pvfs2-usrint.h"

/* helper functions' prototypes */
static void init_keyval_structs(PINT_server_op *s_op, int free_val);

/* NOTICE: I have followed the structure of get-eattr and set-eattr for this
 *         file.  The default set-eattr does not have a response struct so
 *         there is no err_array for it.  Because of this I chose not to modify
 *         the responses err array when errors occur during the set.  If you
 *         choose to modify the err_array yourself please note that once I start
 *         moving val/key/sz triplets around in the req, it becomes complicated
 *         to determine if the ith error in the req comes from ith response or
 *         not. -- ADP
 */

/* TODO: Find out when the key/val/valsz arrays get malloc'd and when they get freed? */

%%

machine pvfs2_atomic_eattr_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => setup_resp;
        default => final_response;
    }
    
    state setup_resp
    {
        run atomiceattr_setup_resp;
        success => read_eattrib;
        default => final_response;
    }

    state read_eattrib
    {
        run atomiceattr_read_eattrib;
        default => check_resp;
    }

    state check_resp
    {
        run atomiceattr_check_resp;
        default => modify_eattrib;
    }

    state modify_eattrib
    {
        run atomiceattr_modify_eattrib;
        default => verify_eattrib;
    }
    
    state verify_eattrib
    {
        run atomiceattr_verify_eattribs;
        success => setobj_eattrib;
        default => final_response;
    }

    state setobj_eattrib
    {
        run atomiceattr_setobj_eattribs;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run atomiceattr_cleanup;
        default => terminate;
    }
}

%%

/*
 * atomiceattr_setup_resp()
 * Set up the response - allocate needed resources
 */
static PINT_sm_action atomiceattr_setup_resp(struct PINT_smcb *smcb,
                                             job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i;

    gossip_debug(GOSSIP_GETEATTR_DEBUG,"atomiceattr requesting %d keys\n",
                 s_op->req->u.atomiceattr.nkey);

    js_p->error_code = 0;

    /* ensure not too many keys were requested */
    if(s_op->req->u.atomiceattr.nkey > PVFS_MAX_XATTR_LISTLEN)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* iterate through the keys and see if they fall into valid name spaces */
    for(i = 0; i < s_op->req->u.atomiceattr.nkey; i++)
    {
        gossip_debug(GOSSIP_GETEATTR_DEBUG, "atomiceattr key %d : %s\n", i, 
                (char *) s_op->req->u.atomiceattr.key[i].buffer);

        /* ensure no buffer_sz is too large */
        if((s_op->req->u.atomiceattr.key[i].buffer_sz >
                                            PVFS_MAX_XATTR_NAMELEN) ||
           (s_op->req->u.atomiceattr.key[i].buffer_sz >
                                            PVFS_MAX_XATTR_VALUELEN) ||
           (s_op->req->u.atomiceattr.key[i].buffer_sz >
                                            PVFS_MAX_XATTR_NAMELEN))
        {
            js_p->error_code = -PVFS_EINVAL;
            return SM_ACTION_COMPLETE;
        }

        js_p->error_code = PINT_eattr_check_access(
                        &s_op->req->u.atomiceattr.key[i],
                        NULL);
        if(js_p->error_code != 0)
        {
            /* not prefixed: treat this as if the key does not exist */
            js_p->error_code = -PVFS_ENOENT;
            return SM_ACTION_COMPLETE;
        }
    }

    /* allocate memory for the array of return values */
    s_op->resp.u.atomiceattr.ret_val = malloc(s_op->req->u.atomiceattr.nkey *
                                              sizeof(PVFS_ds_keyval));
    if (!s_op->resp.u.atomiceattr.ret_val)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocated memory for the array of error codes */
    s_op->resp.u.atomiceattr.err = malloc(s_op->req->u.atomiceattr.nkey *
                                          sizeof(PVFS_error));
    if (!s_op->resp.u.atomiceattr.err)
    {
        free(s_op->resp.u.atomiceattr.ret_val);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocate buffers for return values */
    s_op->resp.u.atomiceattr.nkey = s_op->req->u.atomiceattr.nkey;
    for (i = 0; i < s_op->req->u.atomiceattr.nkey; i++)
    {
        s_op->resp.u.atomiceattr.ret_val[i].buffer =
                                 malloc(PVFS_MAX_XATTR_VALUELEN);
        if (!s_op->resp.u.atomiceattr.ret_val[i].buffer)
        {
            for(--i; i >= 0; --i)
            {
                free(s_op->resp.u.atomiceattr.ret_val[i].buffer);
            }
            s_op->resp.u.atomiceattr.nkey = 0;
            free (s_op->resp.u.atomiceattr.ret_val);
            free (s_op->resp.u.atomiceattr.err);
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
        s_op->resp.u.atomiceattr.ret_val[i].buffer_sz =
                                            PVFS_MAX_XATTR_VALUELEN;
    }

    /* allocate arrays for writeback */
    s_op->key_a = (PVFS_ds_keyval *)malloc(s_op->req->u.atomiceattr.nkey *
                                           sizeof(PVFS_ds_keyval));
    s_op->val_a = (PVFS_ds_keyval *)malloc(s_op->req->u.atomiceattr.nkey *
                                           sizeof(PVFS_ds_keyval));
    for (i = 0; i < s_op->req->u.atomiceattr.nkey; i++)
    {
        s_op->key_a[i].buffer = (char *)malloc(PVFS_MAX_XATTR_NAMELEN);
        s_op->key_a[i].buffer_sz = PVFS_MAX_XATTR_NAMELEN;
        s_op->val_a[i].buffer = (char *)malloc(PVFS_MAX_XATTR_VALUELEN);
        s_op->val_a[i].buffer_sz = PVFS_MAX_XATTR_VALUELEN;
    }
    s_op->free_val = 1;

    return SM_ACTION_COMPLETE;
}

/*
 * atomiceattr_read_eattrib()
 * Here is where the eattrib get read.  Not much to this.
 */
static PINT_sm_action atomiceattr_read_eattrib(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    js_p->error_code = 0;

    ret = job_trove_keyval_read_list(s_op->req->u.atomiceattr.fs_id,
                                     s_op->req->u.atomiceattr.handle,
                                     s_op->req->u.atomiceattr.key,
                                     s_op->resp.u.atomiceattr.ret_val,
                                     s_op->resp.u.atomiceattr.err,
                                     s_op->req->u.atomiceattr.nkey,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &i,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

/*
 * atomiceattr_check_resp()
 * Check the response - handle any errors
 */
static PINT_sm_action atomiceattr_check_resp(struct PINT_smcb *smcb,
                                             job_status_s *js_p)
{
    int ret;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int k;
    gossip_debug(GOSSIP_GETEATTR_DEBUG,"atomiceattr returning %d values\n",
            s_op->resp.u.atomiceattr.nkey);
    gossip_debug(GOSSIP_GETEATTR_DEBUG,"status %d error_code %d nkeys %d\n",
            s_op->resp.status, js_p->error_code, s_op->resp.u.atomiceattr.nkey);
    /* it is the only thing returned across the wire */
    for (k = 0; k < s_op->resp.u.atomiceattr.nkey; k++)
    {
        if (s_op->resp.u.atomiceattr.err[k])
        {
            /* in case of any errors, we initialize it to 0 */
            s_op->resp.u.atomiceattr.ret_val[k].buffer_sz = 0;
            continue;
        }
        /* this checks to see if the attr is a */
        /* list of PVFS handles and if so encodes it */
        ret = PINT_eattr_encode(&s_op->req->u.atomiceattr.key[k],
                                &s_op->resp.u.atomiceattr.ret_val[k]);
        if(ret != 0)
        {
            gossip_err("%s: failed encoding extended attribute: %s\n",
                       __func__,
                       (char *)s_op->req->u.atomiceattr.key[k].buffer);
            s_op->resp.u.atomiceattr.err[k] = ret;
        }

        /* put the returned read buffer size in buffer_sz */
        s_op->resp.u.atomiceattr.ret_val[k].buffer_sz =
                         s_op->resp.u.atomiceattr.ret_val[k].read_sz;
        gossip_debug(GOSSIP_GETEATTR_DEBUG, "key %s, read_sz = %d\n",
            (char *) s_op->req->u.atomiceattr.key[k].buffer, 
            s_op->resp.u.atomiceattr.ret_val[k].buffer_sz);
    }
    
    return SM_ACTION_COMPLETE;
}

/* 
 * Initially the val array in req holds the operands for the operation we are
 * to perform with the currently set eattribs.  For simplicity, we perform the
 * operation and store the result back into the val array.  At this point the
 * val array now holds the values we want to set so that the code below is
 * essentially the same as in set-eattr.sm
 * 
 * Part of the error logic is that if we couldn't read an attribute then we 
 * don't write to that attribute.  This is accomplished by eliminating the
 * key/value/valsz entries from the request that correspond to incorrectly
 * read attributes.  We do the same thing for other errors as well such as
 * improperly sized attributes.  Finally, we adjust the request nkey
 * accordingly.
 */
static int atomiceattr_modify_eattrib(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i;

#if 0
    int num_errors = 0;
    int32_t *oldval = NULL;
    int32_t *newval = NULL;
    PVFS_ds_keyval tmp_key;
    PVFS_ds_keyval tmp_val;
    PVFS_size tmp_valsz;
#endif
    
    js_p->error_code = 0;
    s_op->keyval_count = 0; /* this will control what is written back */
    switch(s_op->req->u.atomiceattr.opcode)
    {
/* This is to be removed in favor of compare and swap */
#if 0
        case PVFS_TEST_AND_SET:
        {
            for(i = 0; i < s_op->req->u.atomiceattr.nkey; i++)
            {
                error[i] = 0;
                
                if(s_op->resp.u.atomiceattr.err[i])
                {
                    error[i] = 1;
                    continue;
                }
                
                /* Determine if the buffers are big enough to hold ints before
                 * we point ints to them and use integer arithmetic. We do not
                 * want to read from or write to memory outside the buffer.
                 */
                if((s_op->resp.u.atomiceattr.val[i].buffer_sz != 
                           sizeof(int32_t)) ||
                   (s_op->req->u.atomiceattr.val[i].buffer_sz !=
                           sizeof(int32_t)))
                {
                    gossip_debug(GOSSIP_SETEATTR_DEBUG,
                            "error: test and set requires 32-bit operands\n");
                    error[i] = 1;
                    continue;
                }
                oldval = (int32_t *)s_op->resp.u.atomiceattr.val[i].buffer;
                newval = (int32_t *)s_op->req->u.atomiceattr.val[i].buffer;
            
                /* Perform the test */
                if(*oldval == 0)
                {
                    *newval = 1;
                }
                else
                {
                    /* NOTE: Not a true error but a no-op instead */
                    error[i] = 1;
                    continue;
                }
            }
            break;
        }
#endif
        /* compare and swap needs two values old and new */
        case PVFS_SWAP:
        {
            for(i = 0; i < s_op->req->u.atomiceattr.nkey; i++)
            {
                int len;
                if(s_op->resp.u.atomiceattr.err[i])
                {
                    /* ignore failed reads */
                    continue;
                }

                /* note that they way this code works is it favors
                 * the size of the old_val.  If the request send an
                 * old_val shorter than the one in the attrib it will
                 * only check for a match of that part of the string
                 * ignoring the rest.  Not sure if we want it that way
                 * but it could be useful.  Change if we decide
                 * otherwise
                 */
                len = s_op->req->u.atomiceattr.old_val[i].buffer_sz;

                if (len > s_op->resp.u.atomiceattr.ret_val[i].buffer_sz)
                {
                    /* attrib shorter than old_val automatic fail */
                    s_op->resp.u.atomiceattr.err[i] = -PVFS_EPERM;
                    continue;
                }

                s_op->keyval_count = 0;
                if (!strncmp(s_op->req->u.atomiceattr.old_val[i].buffer,
                             s_op->resp.u.atomiceattr.ret_val[i].buffer,
                             len))
                {
                    memcpy(&s_op->key_a[s_op->keyval_count],
                           &s_op->req->u.atomiceattr.key[i],
                           sizeof(PVFS_ds_keyval));
                    memcpy(&s_op->val_a[s_op->keyval_count],
                           &s_op->req->u.atomiceattr.new_val[i],
                           sizeof(PVFS_ds_keyval));
                    s_op->keyval_count++;
                }
                else
                {   
                    /* existing attrib does not match attrib sent in
                     * request so we cannot update.  this is sort of
                     * like failing due to permissions, so we'll use
                     * that unless someone finds a better code
                     */
                    s_op->resp.u.atomiceattr.err[i] = -PVFS_EPERM;
                }
            }
            break;
        }
        case PVFS_FETCH_AND_ADD:
        {            
            int32_t val = 0;

            /* Add each of the current eattrib by the requested value
             * The results are stored in the request and these results will be 
             * set to eattribs later
             */       
            for(i = 0; i < s_op->req->u.atomiceattr.nkey; i++)
            {
                if(s_op->resp.u.atomiceattr.err[i])
                {
                    continue;
                }
                
                /* Determine if the buffers are big enough to hold ints before
                 * we point ints to them and use integer arithmetic. We do not
                 * want to read from or write to memory outside the buffer.
                 */
                if((s_op->resp.u.atomiceattr.ret_val[i].buffer_sz !=
                            sizeof(int32_t)) ||
                   (s_op->req->u.atomiceattr.new_val[i].buffer_sz !=
                            sizeof(int32_t)))
                {
                    gossip_debug(GOSSIP_SETEATTR_DEBUG,
                           "error: fetch and add requires 32-bit operands\n");
                    continue;
                }
                
                memcpy(&s_op->key_a[s_op->keyval_count],
                       &s_op->req->u.atomiceattr.key[i],
                       sizeof(PVFS_ds_keyval));

                /* portability issues here 
                 * server doesn't know what is in an eattrib buffer so
                 * it is not byteswapped when sent up or back.  Thus,
                 * for this to work we have to know that the machine
                 * that send this eattrib value is the same as the
                 * server.
                 */
                val = *(int32_t *)s_op->resp.u.atomiceattr.ret_val[i].buffer;
                val += *(int32_t *)s_op->req->u.atomiceattr.new_val[i].buffer;

                *(int32_t *)s_op->val_a[s_op->keyval_count].buffer = val;
                s_op->val_a[s_op->keyval_count].buffer_sz = sizeof(int32_t);

                s_op->keyval_count++;
            }
            break;
        }
        default:
        {
            /* Invalid opcode */
            s_op->req->u.atomiceattr.nkey = 0;
            break;
        }
    }

    if (!s_op->keyval_count)
    {
        js_p->error_code = 1; /* causes SM to skip writeback state */
    }
    
    return SM_ACTION_COMPLETE;
}


/*
 * This routine checks keys to confirm that the name spaces are valid.
 */
static int atomiceattr_verify_eattribs(struct PINT_smcb *smcb, 
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i; 

    gossip_debug(GOSSIP_MIRROR_DEBUG,"Current Frame Pointer in atomic-eattr.sm "
                                     "is %p.\n",s_op);       

    PVFS_object_attr *a_p = NULL;
    a_p = &s_op->attr;

    js_p->error_code = 0;

    gossip_debug(GOSSIP_SETEATTR_DEBUG,
                 "  ext attr list write to handle %s refers to a %s\n\t"
                 "[owner = %d, group = %d, perms = %o, type = %d]\n",
                 PVFS_OID_str(&s_op->req->u.atomiceattr.handle),
                 PINT_util_get_object_type(a_p->objtype),
                 a_p->owner, a_p->group, a_p->perms, a_p->objtype);

    /* We already checked the number of args and the name lengths before
     * retrieving the currently set attributes
     * So checking the value lengths is all that we need to do here
     */
    for( i = 0; i < s_op->keyval_count; i++ )
    {
        if(s_op->val_a[i].buffer_sz > PVFS_MAX_XATTR_VALUELEN)
        {
            js_p->error_code = -PVFS_EINVAL;
            return SM_ACTION_COMPLETE;
        }
    }

    /* verify the namespace for each key - should have been done already */
    int j = 0;
    char *valBuf = NULL;
    for (i = 0; i < s_op->keyval_count; i++)
    {
#ifndef GOSSIP_DISABLE_DEBUG
        if (gossip_debug_on)
        {
            gossip_debug(GOSSIP_MIRROR_DEBUG
                        ,"\tkey:%s\n"
                        ,(char *)s_op->key_a[i].buffer);
            valBuf = (char *)s_op->val_a[i].buffer;
            for (j = 0; j < s_op->val_a[i].buffer_sz; j++)
            {
                gossip_debug(GOSSIP_MIRROR_DEBUG,"\tval_a[%d]=%#x\n"
                                                ,j
                                                ,(unsigned int)valBuf[j]);
            }
        }
#endif
        js_p->error_code = PINT_eattr_namespace_verify(&s_op->key_a[i],
                                                       &s_op->val_a[i]);

        if(js_p->error_code)
        {
            return SM_ACTION_COMPLETE;
        }

    } /*end for*/


    return SM_ACTION_COMPLETE;
}


/*
 * This is where the actual extended attrib gets written.
 * Not much to this, its pretty straight-forward.
 * 
 * Since atomiceattr is always doing a replace, we set trove flag
 * TROVE_ONLYOVERWRITE
 * 
 * NOTE: Currently we are not using the flags passed in the request
 */
static int atomiceattr_setobj_eattribs(struct PINT_smcb *smcb, 
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    PVFS_ds_flags trove_flags = 0;
    job_id_t j_id;

    gossip_debug(GOSSIP_SETEATTR_DEBUG,
                 "  writing keylist [%s,%d,len %d flags %d]\n",
                 PVFS_OID_str(&s_op->req->u.atomiceattr.handle),
                 s_op->req->u.atomiceattr.fs_id,
                 s_op->req->u.atomiceattr.nkey, s_op->req->u.atomiceattr.flags);

    trove_flags |= TROVE_ONLYOVERWRITE;
    trove_flags |= TROVE_SYNC;

    ret = job_trove_keyval_write_list(s_op->req->u.atomiceattr.fs_id,
                                      s_op->req->u.atomiceattr.handle,
                                      s_op->key_a,
                                      s_op->val_a,
                                      s_op->keyval_count,
                                      trove_flags,
                                      NULL,
                                      smcb,
                                      0,
                                      js_p,
                                      &j_id,
                                      server_job_context,
                                      s_op->req->hints);

    return ret;
}

/*
 * Function: atomiceattr_cleanup
 *
 * Params:   server_op *b, 
 *           job_status_s *js_p
 *
 * Returns:  int
 *
 * Synopsis: free memory and return
 *           
 */
static int atomiceattr_cleanup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    int i;
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    
    if (s_op->resp.u.atomiceattr.ret_val)
    {
        for(i = 0; i < s_op->resp.u.atomiceattr.nkey; i++)
        {
            free(s_op->resp.u.atomiceattr.ret_val[i].buffer);
        }
        free(s_op->resp.u.atomiceattr.ret_val);
    }
    if (s_op->resp.u.atomiceattr.err)
    {
        free(s_op->resp.u.atomiceattr.err);
    }

    /*free key/val structs from the s_op*/
    init_keyval_structs(s_op,s_op->free_val);

    return(server_state_machine_complete(smcb));
}

/* This function initializes the keyval structures.
 * It also assumes that the key is always allocated, while the val may not be.
 * free_val is turned on, if the val must be deallocated; otherwise, val is
 * not deallocated, just initialized.
 */
static void init_keyval_structs(PINT_server_op *s_op, int free_val)
{
   int i;

   /* initialize val */
   if (free_val)
   {
       if (s_op->val.buffer)
       {
           free(s_op->val.buffer);
       }
       memset(&(s_op->val), 0, sizeof(PVFS_ds_keyval));
       for (i = 0; i < s_op->keyval_count; i++)
       {
           if (s_op->val_a && s_op->val_a[i].buffer)
           {
               free(s_op->val_a[i].buffer);
           }
       }
       if (s_op->val_a)
       {
           free(s_op->val_a);
       }
       s_op->val_a = NULL;
   } 
   else
   {
       memset(&(s_op->val), 0, sizeof(PVFS_ds_keyval));
       if (s_op->val_a)
       {
           free(s_op->val_a);
       }
       s_op->val_a = NULL;
   }

   /* initialize key */
   if (s_op->key.buffer)
   {
       free(s_op->key.buffer);
       memset(&(s_op->key), 0, sizeof(PVFS_ds_keyval));
   }
   for (i = 0; i < s_op->keyval_count; i++)
   {
       if (s_op->key_a && s_op->key_a[i].buffer)
       {
           free(s_op->key_a[i].buffer);
       }
   }
   if (s_op->key_a)
   {
       free(s_op->key_a);
       s_op->key_a = NULL;
   } 

   /* initialize the rest */
   if (s_op->error_a)
   {
       free(s_op->error_a);
   }
   s_op->error_a = NULL;
   s_op->keyval_count = 0;
   s_op->free_val = 0;

   return;
}/* end init_keyval_structs */

static int perm_atomiceattr(PINT_server_op *s_op)
{
    int ret;

    if (s_op->req->capability.op_mask & PINT_CAP_SETATTR)
    {
        ret = 0;
    }
    else
    {
        ret = -PVFS_EACCES;
    }

    return ret;
}

static void atomiceattr_get_ctrl(struct PVFS_server_req *req,
                                 struct PINT_server_req_ctrl *ctrl)
{
    /* this sets up a standard replication */
    /* generates a request to each of sid_count SIDs */
    /* all with the same UID */
    ctrl->fs_id = req->u.atomiceattr.fs_id;
    ctrl->handles = &req->u.atomiceattr.handle;
    ctrl->count = 1;
    ctrl->sids = req->u.atomiceattr.sid_array;
    ctrl->sid_count = req->u.atomiceattr.sid_count;
}

PINT_GET_OBJECT_REF_DEFINE(atomiceattr);

struct PINT_server_req_params pvfs2_atomic_eattr_params =
{
    .string_name = "atomic_eattr",
    .perm = perm_atomiceattr,
    .get_ctrl = atomiceattr_get_ctrl,
    .access_type = PINT_server_req_modify,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_attr = NULL,
    .get_object_ref = PINT_get_object_ref_atomiceattr,
    .state_machine = &pvfs2_atomic_eattr_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
