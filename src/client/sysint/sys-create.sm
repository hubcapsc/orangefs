/* 
 * Copyright Â© Acxiom Corporation, 2006
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "pvfs2-dist-varstrip.h"
#include "sid.h"
#include "pvfs-sid.h"
#include "dist-dir-utils.h"
#include "server-config.h"
#include "client-capcache.h"

enum
{
    CREATE_RETRY = 170
};

/* completion function prototypes */
static int create_comp_fn(void *v_p,
                          struct PVFS_server_resp *resp_p,
                          int index);
static int create_crdirent_comp_fn(void *v_p,
                                   struct PVFS_server_resp *resp_p,
                                   int index);
static int create_delete_handles_comp_fn(void *v_p,
                                         struct PVFS_server_resp *resp_p,
                                         int index);

/* misc helper functions */
static PINT_dist* get_default_distribution(PVFS_fs_id fs_id);

%%

machine pvfs2_client_create_sm
{
    /* setup to getattr parent */

    state init
    {
        run create_init;
        default => parent_getattr;
    }

    state parent_getattr
    {
        jump pvfs2_client_getattr_sm;
        success => parent_getattr_inspect;
        default => cleanup;
    }

    state parent_getattr_inspect
    {
        run create_parent_getattr_inspect;
        success => create_setup_msgpair;
        default => cleanup;
    }

    /* set up to create the metafile */

    state create_setup_msgpair
    {
        run create_create_setup_msgpair;
        success => create_xfer_msgpair;
        default => cleanup;
    }

    state create_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => crdirent_setup_msgpair;
        default => cleanup;
    }

    /* set up to make the dirent for new file */

    state crdirent_setup_msgpair
    {
        run create_crdirent_setup_msgpair;
        success => crdirent_xfer_msgpair;
        default => crdirent_failure;
    }

    state crdirent_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => cleanup;
        default => crdirent_failure;
    }

    state crdirent_failure
    {
        run create_crdirent_failure;
        success => crdirent_getattr;
        default => delete_handles_setup_msgpair_array;
    }

    /* read attrs with cap etc */

    state crdirent_getattr
    {   
        jump pvfs2_client_getattr_sm;
        success => crdirent_setup_msgpair;
        default => crdirent_failure;
    }              

    /* undo what we can on an error */
        
    state delete_handles_setup_msgpair_array
    {
        run create_delete_handles_setup_msgpair_array;
        success => delete_handles_xfer_msgpair_array;
        default => cleanup;
    }

    state delete_handles_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        default => cleanup;
    }

    /* final cleanup */

    state cleanup
    {
        run create_cleanup;
        CREATE_RETRY => init;
        default => terminate;
    }
}

%%

/** Initiate creation of a file with a specified distribution.
 */
PVFS_error PVFS_isys_create(char *object_name,
                            PVFS_object_ref parent_ref,
                            PVFS_sys_attr attr,
                            const PVFS_credential *credential,
                            PVFS_sys_dist *dist,
                            PVFS_sys_layout *layout,
                            PVFS_sysresp_create *resp,
                            PVFS_sys_op_id *op_id,
                            PVFS_hint hints,
                            void *user_ptr)
{
    PVFS_error ret = -PVFS_EINVAL;
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;
    struct server_configuration_s *server_config = NULL;
    struct filesystem_configuration_s *fs_config = NULL;
    PVFS_object_attr *file_attr = NULL;
    PVFS_size default_strip_size = 65536;

    gossip_debug(GOSSIP_CREATE_DEBUG, "PVFS_isys_create entered\n");

    if (!PVFS_OID_cmp(&parent_ref.handle, &PVFS_HANDLE_NULL) ||
        (parent_ref.fs_id == PVFS_FS_ID_NULL) ||
        (object_name == NULL) || (resp == NULL))
    {
        gossip_err("invalid (NULL) required argument\n");
        return ret;
    }

    /* check to make sure all expected attributes are present */
    if ((attr.mask & PVFS_ATTR_SYS_CREATE_REQUIRED) != PVFS_ATTR_SYS_CREATE_REQUIRED)
    {
        gossip_lerr("PVFS_isys_create() failure: invalid attribute mask: %lu, "
                    "expected SYS_ALL_SETABLE (%lu)\n",
                    attr.mask, PVFS_ATTR_SYS_CREATE_REQUIRED);
        return ret;
    }

    /* useless, if SYS_DFILE_COUNT is set previous test will error out */
    if ((attr.mask & PVFS_ATTR_SYS_DFILE_COUNT) &&
        ((attr.dfile_count < 1) ||
         (attr.dfile_count > PVFS_REQ_LIMIT_DFILE_COUNT)))
    {
        gossip_err("Error: invalid number of datafiles (%d) specified "
                   "in PVFS_sys_create().\n", (int)attr.dfile_count);
        return ret;
    }

    if ((strlen(object_name) + 1) > PVFS_REQ_LIMIT_SEGMENT_BYTES)
    {
        return -PVFS_ENAMETOOLONG;
    }

#ifndef ENABLE_SECURITY_CERT
    /* if owner/group differ from credential values, and credential is 
       not for root, create with owner/group equal to credential values
       (in cert. mode the credential fields aren't used) */
    if (attr.owner != credential->userid &&
        credential->userid != 0)
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, "Replacing owner uid %d with %d "
                     "on create\n", attr.owner, credential->userid);
        attr.owner = credential->userid;
    }

    if (attr.group != credential->group_array[0] && 
        credential->group_array[0] != 0)
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, "Replacing group gid %d with %d "
                     "on create\n", attr.group, credential->group_array[0]);
        attr.group = credential->group_array[0];
    }
#endif

    gossip_debug(GOSSIP_CREATE_DEBUG, "create Allocating SMCB\n\n");
    PINT_smcb_alloc(&smcb,
                    PVFS_SYS_CREATE,
                    sizeof(struct PINT_client_sm),
                    client_op_state_get_machine,
                    client_state_machine_terminate,
                    pint_client_sm_context);

    if (smcb == NULL)
    {
        return -PVFS_ENOMEM;
    }
    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    PINT_init_msgarray_params(sm_p, parent_ref.fs_id);
    PINT_init_sysint_credential(sm_p->cred_p, credential);
    sm_p->u.create.create_resp = resp;
    sm_p->u.create.object_name = object_name;
    file_attr = &sm_p->u.create.attr;

    /* Rather than convert and toss the sys_attrs, save them so we can apply them
     * last in the validate function
     */
    //PINT_CONVERT_ATTR(&sm_p->u.create.attr, &attr, PVFS_ATTR_META_ALL);
    PVFS_util_copy_sys_attr(&sm_p->u.create.sys_attr, &attr);

    sm_p->u.create.stored_error_code = 0;
    sm_p->u.create.retry_count = 0;

    gossip_debug(GOSSIP_CREATE_DEBUG, "create Adding hints\n\n");
    PVFS_hint_copy(hints, &sm_p->hints);
    PVFS_hint_add(&sm_p->hints,
                  PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle),
                  &parent_ref.handle);

    sm_p->parent_ref = parent_ref;

    /* We will start building attributes for the new file object
     * In this function we will add attributes to sm_p->u.create.attr
     * first from the built-in defaults, second from config file defaults,
     * In the validate function - after we have read the parent attributes
     * we continue with third from the parent directory attributes and hints,
     * and finally from the sys_attrs passed in to the sys_mkdir call.
     */

    /*********************/
    /* Built-in defaults */
    /*********************/

    /* General attributes */
    file_attr->objtype = PVFS_TYPE_METAFILE;
    file_attr->mask |= PVFS_ATTR_COMMON_TYPE;
    file_attr->owner = credential->userid;
    file_attr->mask |= PVFS_ATTR_COMMON_UID;
    file_attr->group = credential->group_array[0];
    file_attr->mask |= PVFS_ATTR_COMMON_GID;
    file_attr->perms = 0700;
    file_attr->mask |= PVFS_ATTR_COMMON_PERM;
    file_attr->meta_sid_count = 1;
    file_attr->mask |= PVFS_ATTR_COMMON_SID_COUNT;
    file_attr->parent = NULL;
    file_attr->parent_sids = NULL;
    /* attributes pertaining to files */
    /* 
     * NEED to figure out distributions and parameters here
     * ALSO layout - do we need to have layout any more?
     */
    file_attr->u.meta.dist = PINT_dist_create(PVFS_DIST_SIMPLE_STRIPE_NAME);
    /* set strip_size paramater for simple_stripe */
    PINT_dist_setparams(file_attr->u.meta.dist, (void *)&default_strip_size);
    file_attr->mask |= PVFS_ATTR_META_DIST;
    file_attr->u.meta.dist_size = 0; /* decode only */
    file_attr->u.meta.dfile_count = 1;   /* zero out for transmit */
    file_attr->mask |= PVFS_ATTR_META_DFILE_COUNT;
    file_attr->u.meta.dfile_array = NULL;
    file_attr->u.meta.sid_count = 1;   /* zero out for transmit */
    file_attr->mask |= PVFS_ATTR_META_SID_COUNT;
    file_attr->u.meta.sid_array = NULL;
    file_attr->u.meta.mirror_mode = 0;
    file_attr->mask |= PVFS_ATTR_META_MIRROR_MODE;
    file_attr->u.meta.size = 0;
    file_attr->u.meta.flags = 0;
                                                                    
    /*********************************/
    /* Defaults from the config file */
    /*********************************/

    /* get config for this filesystem */
    server_config = PINT_get_server_config_struct(parent_ref.fs_id);
    fs_config = PINT_config_find_fs_id(server_config, parent_ref.fs_id);

    if (fs_config->default_num_dfiles > 0)
    {
        file_attr->u.meta.dfile_count =    /* zero out for transmit */
                        fs_config->default_num_dfiles;
        file_attr->mask |= PVFS_ATTR_META_DFILE_COUNT;
    }
    if (fs_config->default_dfile_replication_factor > 0)
    {
        file_attr->u.meta.sid_count =    /* zero out for transmit */
                        fs_config->default_dfile_replication_factor;
        file_attr->mask |= PVFS_ATTR_META_SID_COUNT;
    }
    if (fs_config->metadata_replication_factor > 0)
    {
        file_attr->meta_sid_count =
                        fs_config->metadata_replication_factor;
        file_attr->mask |= PVFS_ATTR_COMMON_SID_COUNT;
    }

    /* return checked out verion of config struct */
    PINT_put_server_config_struct(server_config);

    /* Distributions are a little more complicated */
    if (server_config && server_config->default_dist_config.name)
    {
        /* free the system default */
        PINT_dist_free(file_attr->u.meta.dist);
        /* allocates packed dist */
        file_attr->u.meta.dist = get_default_distribution(sm_p->parent_ref.fs_id);
        file_attr->mask |= PVFS_ATTR_META_DIST;
        /* dist_size is only used by decode to report the size of the dist */
    }

    /********************************************/
    /* Defaults deferred to SM inspection state */
    /********************************************/

    if((attr.mask & PVFS_ATTR_SYS_DFILE_COUNT) && (0 < attr.dfile_count))
    {
        sm_p->u.create.user_requested_num_data_files = attr.dfile_count;
    }
    else
    {
        /* don't assume field is clean */
        sm_p->u.create.user_requested_num_data_files = 0;
    }

/******* OLD CODE HERE *******/
#if 0
    gossip_debug(GOSSIP_CREATE_DEBUG, "checking sid/uid counts\n");
    /* v3 need to add config default and dir override ability */
    server_config = pint_get_server_config_struct(parent_ref.fs_id);
    fs_config = pint_config_find_fs_id(server_config, parent_ref.fs_id);
    pint_put_server_config_struct(server_config);
    sm_p->u.create.metadata_sid_count =
                            fs_config->metadata_replication_factor;
    sm_p->u.create.datafile_sid_count =
                            fs_config->default_dfile_replication_factor;
    if (sm_p->u.create.metadata_sid_count <= 0)
    {
        sm_p->u.create.metadata_sid_count = 1;
    }
    if (sm_p->u.create.datafile_sid_count <= 0)
    {
        sm_p->u.create.datafile_sid_count = 1;
    }
#endif

    /* if user supplies layout, copy layout to sm struct 
     * layout will be used in SM
     */
    if(layout)
    {
        gossip_debug(GOSSIP_CREATE_DEBUG,"saving supplied layout\n");
        /* make sure it is a supported layout */
        if ((layout->algorithm <= PVFS_SYS_LAYOUT_NULL) ||
            (layout->algorithm > PVFS_SYS_LAYOUT_MAX))
        {
            return(-PVFS_EINVAL);
        }

        sm_p->u.create.layout.algorithm = layout->algorithm;
        if(layout->algorithm == PVFS_SYS_LAYOUT_LIST)
        {
            /* copy list of servers */
            sm_p->u.create.layout.server_list.count =
                    layout->server_list.count;
            sm_p->u.create.layout.server_list.servers =
                    malloc(layout->server_list.count * sizeof(PVFS_BMI_addr_t));
            if(!sm_p->u.create.layout.server_list.servers)
            {
                return -PVFS_EINVAL;
            }
            memcpy(sm_p->u.create.layout.server_list.servers,
                   layout->server_list.servers,
                   layout->server_list.count * sizeof(PVFS_BMI_addr_t));
        }
    }
    else
    {
        /* we check for dir hint in another state and
         * then set default if there is no other layout
         */
        sm_p->u.create.layout.algorithm = PVFS_SYS_LAYOUT_NULL;
    }

    /* distribution must be passed with the req and stored as part of
     * the attributes, so we should handle like other attributes.
     */
    /* if the user specifies a distribution copy it for acces in SM.
     * We do this because another default layer is the parent which may
     * override the dist supplied in this func above, and may again be
     * overridden by the user via this reference, so we pass this
     * reference on to the SM so it can do the parent first, and then
     * the user.  That way all priorities come out right.
     */
    if (dist)
    {
        gossip_debug(GOSSIP_CREATE_DEBUG,"saving supplied distribution\n");
        if (!dist->name)
        {
            PINT_smcb_free(smcb);
            return -PVFS_EINVAL;
        }

        sm_p->u.create.dist = PINT_dist_create(dist->name);
        if (!sm_p->u.create.dist)
        {
            PINT_smcb_free(smcb);
            return -PVFS_ENOMEM;
        }
        sm_p->u.create.dist->params = dist->params;
    }
    else
    {
        /* leave null for now we will check if there is
         * a dir hint and if no then get the deffault
         */
        sm_p->u.create.dist = NULL;
#if 0
        /* get the default distribution */
        sm_p->u.create.dist = get_default_distribution(sm_p->parent_ref.fs_id);
        if (!sm_p->u.create.dist)
        {
            pint_smcb_free(smcb);
            return -pvfs_enomem;
        }
#endif
    }

    /* Save the original attribute passed in. since create does it's own
     * retries we need the original attribute available on retries.
     */
    PINT_copy_object_attr(&(sm_p->u.create.store_attr),
                          &(sm_p->u.create.attr));

    gossip_debug(GOSSIP_CLIENT_DEBUG, "creating file %s under %s, %d\n",
                 object_name, PVFS_OID_str(&parent_ref.handle),
                 parent_ref.fs_id);

    gossip_debug(GOSSIP_CREATE_DEBUG,"posting state machine.\n");
    ret = PINT_client_state_machine_post(smcb, op_id, user_ptr);
    return ret;
}

/**Main CREATE system call 
 * create a file with a specified distribution, layout, attr, etc.
 */
PVFS_error PVFS_sys_create(
    char *object_name,                 /**< name of the file to create */
    PVFS_object_ref parent_ref,        /**< handle of the parent dir */
    PVFS_sys_attr attr,                /**< attributes of new file */
    const PVFS_credential *credential, /**< identity of the caller */
    PVFS_sys_dist *dist,               /**< distribution of new file */
    PVFS_sysresp_create *resp,         /**< response from the request */
    PVFS_sys_layout *layout,           /**< selection of servers to hold file */
    PVFS_hint hints)                   /**< user supplied pvfs hints */
{
    PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_sys_op_id op_id;

{ fprintf(stderr, "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&\n"); }

    gossip_debug(GOSSIP_CLIENT_DEBUG, "pvfs_sys_create entered\n");

    /* Call the asynchronous version */

    ret = PVFS_isys_create(object_name,
                           parent_ref,
                           attr,
                           credential,
                           dist,
                           layout,
                           resp,
                           &op_id,
                           hints,
                           NULL);
    if (ret)
    {
        PVFS_perror_gossip("pvfs_isys_create call", ret);
        error = ret;
    }
    else if (!ret && op_id != -1)
    {
        /* Wait for it to complete */
        gossip_debug(GOSSIP_CREATE_DEBUG,"waiting for state machine.\n");
        ret = PVFS_sys_wait(op_id, "create", &error);
        if (ret)
        {
            PVFS_perror_gossip("pvfs_sys_wait call", ret);
            error = ret;
        }
        PINT_sys_release(op_id);
    }
    return error;
}

/* <====================== completion funcitons ========================> */

static int create_comp_fn(void *v_p,
                          struct PVFS_server_resp *resp_p,
                          int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_create_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CREATE);

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }

/* there really isn't anything to do any more - the rest of this stuff
 * is not needed any more - but if we want to return creation times from
 * the new object we would need to get them here and stash them in the
 * attr struct in the frame.
 */

/* v3 handles no longer returned from metaserver but passed to it */
#if 0
    /* otherwise, just stash the newly created meta handle */
    sm_p->u.create.datafile_count = resp_p->u.create.datafile_count;

    sm_p->u.create.datafile_handles = malloc(
                                    sizeof(*sm_p->u.create.datafile_handles) *
                                    sm_p->u.create.datafile_count);

    if(!sm_p->u.create.datafile_handles)
    {
       return ret;
    }

    memcpy(sm_p->u.create.datafile_handles,
           resp_p->u.create.datafile_handles,
           (sizeof(*sm_p->u.create.datafile_handles) *
                resp_p->u.create.datafile_count));

    sm_p->u.create.sid_count = resp_p->u.create.sid_count;

    sm_p->u.create.sid_array = malloc(sizeof(*sm_p->u.create.sid_array) *
                                      sm_p->u.create.sid_count);

    if (!sm_p->u.create.sid_array)
    {
        free(sm_p->u.create.datafile_handles);
        return -pvfs_enomem;
    }

    memcpy(sm_p->u.create.sid_array,
           resp_p->u.create.sid_array,
           (sizeof(*sm_p->u.create.sid_array) * resp_p->u.create.sid_count));

    sm_p->u.create.stuffed = resp_p->u.create.stuffed;
#endif
/* none of this makes sense - the items on the right were initialized
 * from the items on the left before the operation, and in any event
 * none of them would change: the request nolonger changes or modifies
 * this stuff.
 */
#if 0
    sm_p->u.create.datafile_count =
                       sm_p->msgarray_op.msgpair.req.u.create.datafile_count;
    sm_p->u.create.datafile_handles =
                       sm_p->msgarray_op.msgpair.req.u.create.datafile_handles;
    sm_p->u.create.sid_count = sm_p->msgarray_op.msgpair.req.u.create.sid_count;
    sm_p->u.create.sid_array = sm_p->msgarray_op.msgpair.req.u.create.sid_array;
    /* sm_p->u.create.stuffed = sm_p->msgarray_op.msgpair.req.u.create.stuffed; */

    gossip_debug(gossip_client_debug,
                 "*** got newly created handle %s\n",
                 pvfs_oid_str(&sm_p->object_ref.handle));
#endif

    return 0;
}

static int create_crdirent_comp_fn(void *v_p,
                                   struct PVFS_server_resp *resp_p,
                                   int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_crdirent_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CRDIRENT);
    return resp_p->status;
}

static int create_delete_handles_comp_fn(void *v_p,
                                         struct PVFS_server_resp *resp_p,
                                         int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_delete_handles_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_REMOVE);

    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "Failed to remove handle number %d\n", index);
    }
    return resp_p->status;
}

/* <====================== ACTION FUNCITONS ========================> */

static PINT_sm_action create_init(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;

    assert((js_p->error_code == 0) ||
           (js_p->error_code == CREATE_RETRY));

    gossip_debug(GOSSIP_CREATE_DEBUG, "Create state: create_init.\n");
    /* set up to read the attributes of the parent,
     * which must be a directory 
     */

    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);

    PINT_SM_GETATTR_STATE_FILL(sm_p->getattr,
                               sm_p->parent_ref,
                               (PVFS_ATTR_COMMON_NOTIME |
                                    PVFS_ATTR_DIR_ALL |
                                    PVFS_ATTR_DIR_HINT_ALL |
                                    PVFS_ATTR_CAPABILITY |
                                    PVFS_ATTR_DISTDIR_ATTR), 
                               PVFS_TYPE_DIRECTORY,
                               0);

    if (js_p->error_code == CREATE_RETRY)
    {
        /* reset the attributes to what got passed in to the sysint call and
         * the config file defaults. the retry path comes through here so we'll
         * want to reset it after each try. 
         */
        if (sm_p->u.create.retry_count > 0)
        {
            PINT_copy_object_attr(&(sm_p->u.create.attr), 
                                  &(sm_p->u.create.store_attr));
        }
        js_p->error_code = 0;
        gossip_debug(GOSSIP_CREATE_DEBUG, "Calling post timer\n");

        return job_req_sched_post_timer(sm_p->msgarray_op.params.retry_delay,
                                        smcb,
                                        0,
                                        js_p,
                                        &tmp_id,
                                        pint_client_sm_context);
    }    
    gossip_debug(GOSSIP_CREATE_DEBUG, "Returning from create_init\n");
    return SM_ACTION_COMPLETE;
}

/** create_parent_getattr_inspect
 * Looks at the attributes of the parent directory and decides if it impacts
 * the file creation in any way
 *
 * Determine the number of dfiles and sids involved, which may be
 * impacted by the parent dir attrs
 */
static PINT_sm_action create_parent_getattr_inspect(struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *pattr = NULL;
    PVFS_object_attr *file_attr = NULL;
    PVFS_sys_attr *sys_attr = NULL;
    PINT_dist *current_dist; 
    int set_new_dist = 0;
    int ret = 0;
    int num_dfiles_requested = 0;
    int tmp_i;

    /* dumps from debugging gossip */
#if 0
    { fprintf(stderr, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
      PVFS_debug_mask dm; int m1, m2, fl; 
      gossip_get_debug_mask(&fl, &dm); m1 = dm.mask1; m2 = dm.mask2;
      fprintf(stderr, "Mask: %x %x\n", m1, m2);
    }
#endif

    gossip_debug(GOSSIP_CREATE_DEBUG, "Create state: parent_getattr_inspect.\n");


    file_attr = &sm_p->u.create.attr; /* attributes of the new file sent with req */

    pattr = &sm_p->getattr.attr;      /* attributes of parent directory from getattr */
    assert(pattr);  /* does this really detect an error? */

    sys_attr = &sm_p->u.create.sys_attr; /* attributes passed in by user in SYS format */


    gossip_debug(GOSSIP_CREATE_DEBUG,
                 "parent owner: %d, group: %d, perms: %d\n",
                 (int)pattr->owner, (int)pattr->group, (int)pattr->perms);

    PINT_debug_capability(&pattr->>capability, "create_parent_getattr_inspect");

    /*
     * We resume processing defaults and their impact on attributes and other
     * parameters that affect file creation.  We process the parent attributes
     * first as they override system defaults and config defaults.  Then we
     * work on user supplied values which override everything else.
     */
    /* Priority for new file object attributes such as:
     * number of data files / distribution, etc.
     * 1) values passed into sys_mkdir
     * 2) directory hints
     * 3) inherit parent attributes
     * 4) mount options (not yet implemented)  -- N/A
     * 5) config file defaults                 -- DONE in isys_create
     * 6) system default (compiled in limits)  -- DONE in isys_create

    /***************************************/
    /* Defaults from the Parent Attributes */
    /***************************************/

    /* do we have a setgid bit? */
    if (pattr->perms & PVFS_G_SGID)
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, "parent has setgid bit set.\n");
        gossip_debug(GOSSIP_CREATE_DEBUG, " - modifying requested attr "
                                          "for new file.\n");
        sm_p->u.create.attr.group = pattr->group;
        /* note that permission checking is left to server even in this case */
    }

#ifdef ENABLE_SECURITY_CERT
    /* we need to know the correct owner group in cert. mode */
    gossip_debug(GOSSIP_CLIENT_DEBUG, "adding gid hint: %d\n", 
                             sm_p->u.create.attr.group);
    PVFS_hint_add(&sm_p->hints, 
                  PVFS_HINT_OWNER_GID_NAME, 
                  sizeof(uint32_t),
                  &sm_p->u.create.attr.group);
#endif

#define SET_FILE_ATTR_FROM_PARENT(d_attr, mbit, p_attr)                \
    if (((pattr->p_attr) > 0) && PVFS2_attr_all(pattr->mask, (mbit)))  \
    {                                                                  \
        dir_attr->d_attr = pattr->p_attr;                              \
        dir_attr->mask |= mbit;                                        \
        gossip_debug(GOSSIP_CREATE_DEBUG, "Add attr %ld\n", mbit);     \
    }

    /* from parent */
    if (pattr->meta_sid_count > 0 && (pattr->mask & PVFS_ATTR_COMMON_SID_COUNT))
    {  
        file_attr->meta_sid_count = pattr->meta_sid_count; 
        file_attr->mask |= PVFS_ATTR_COMMON_SID_COUNT; 
        gossip_debug(GOSSIP_CREATE_DEBUG, "Add attr %ld\n", PVFS_ATTR_COMMON_SID_COUNT);  
    }
    file_attr->parent          /* set to parent OID */
    file_attr->parent_sids     /* set to parent SIDs */

    /* set distribution from parent dir hints if present */
    /*
    file_attr->u.meta.dist =
    file_attr->u.meta.distsize =

    Do we call split_keyval crap?

    pattr->u.dir.hint.dist_name_len
    pattr->u.dir.hint.dist_name
    pattr->u.dir.hint.dist_params_len
    pattr->u.dir.hint.dist_params
    */

    if (pattr->u.dir.hint.dfile_count > 0 && 
        (pattr->mask & PVFS_ATTR_DIR_HINT_DFILE_COUNT))
    {  
        file_attr->u.meta.dfile_count = pattr->u.dir.hint.dfile_count; 
        file_attr->mask |= PVFS_ATTR_META_DFILE_COUNT; 
        gossip_debug(GOSSIP_CREATE_DEBUG, "Add attr %ld\n", PVFS_ATTR_META_DFILE_COUNT);  
    }
    if (pattr->u.dir.hint.dfile_sid_count > 0 && 
        (pattr->mask & PVFS_ATTR_DIR_HINT_DFILE_SID_COUNT))
    {  
        file_attr->u.meta.sid_count = pattr->u.dir.hint.dfile_sid_count; 
        file_attr->mask |= PVFS_ATTR_META_DFILE_COUNT; 
        gossip_debug(GOSSIP_CREATE_DEBUG, "Add attr %ld\n", PVFS_ATTR_META_SID_COUNT);  
    }

    /* !!! change more later */
    if (gossip_debug_enabled(GOSSIP_CREATE_DEBUG))
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, "create_parent_getattr: [%p]\n"
                 "                     dirdata_oid_count     = %d\n"
                 "                     dirdata_sid_count     = %d\n"
                 "                     dfile_count(hint)     = %d\n"
                 "                     dist_name_len(hint)   = %d\n"
                 "                     dist_params_len(hint) = %d\n",
                 pattr,
                 pattr->u.dir.dist_dir_attr.dirdata_count,
                 pattr->u.dir.dist_dir_attr.sid_count,
                 pattr->u.dir.hint.dfile_count,
                 pattr->u.dir.hint.dist_name_len,
                 pattr->u.dir.hint.dist_params_len);

    /* !!! change more later */
        for (tmp_i = 0;
             tmp_i < pattr->u.dir.dist_dir_attr.dirdata_count; tmp_i++)
        {
            gossip_debug(GOSSIP_CREATE_DEBUG,
                     " dirdata_handles[%d] = %s\n",
                     tmp_i, PVFS_OID_str(&pattr->u.dir.dirdata_handles[tmp_i]));
        }
        for (tmp_i = 0; tmp_i < pattr->u.dir.dist_dir_attr.sid_count; tmp_i++)
        {
            gossip_debug(GOSSIP_CREATE_DEBUG,
                     " dirdata_sids[%d] = %s\n",
                     tmp_i, PVFS_SID_str(&pattr->u.dir.dirdata_sids[tmp_i]));
        }
    }

    /* may just use sm_p->getattr.attr.u.dir...
    sm_p->u.create.dirent_handle = malloc(
            sizeof(*pattr->dirdata_handles) * pattr->dist_dir_attr.dirdata_count);
    if (!sm_p->u.create.dirent_handle)
    {
        return -PVFS_ENOMEM;
    }
    memcpy(sm_p->u.create.dirent_handle,
           pattr->dirdata_handles,
           sizeof(*attr->dirdata_handles) * pattr->dist_dir_attr.dirdata_count);

    sm_p->u.create.dirent_file_count = pattr->dist_dir_attr.dirdata_count;
    */

    current_dist = sm_p->u.create.dist;
    /* If we have an overriding distribution for this directory honor that */

    if (!current_dist && pattr->u.dir.hint.dist_name_len > 0)
    {
        PINT_dist *new_dist = NULL;
        new_dist = PINT_dist_create(pattr->u.dir.hint.dist_name);
        if (new_dist)
        {
            gossip_debug(GOSSIP_CREATE_DEBUG,
                         "Setting distribution to %s\n",
                         pattr->u.dir.hint.dist_name);
            PINT_dist_free(current_dist);
            sm_p->u.create.dist = new_dist;
            current_dist = new_dist;
        }
        else
        {
            gossip_debug(GOSSIP_CREATE_DEBUG,
                         "ran out of memory creating distribution\n");
            js_p->error_code = -PVFS_EINVAL;
            return SM_ACTION_COMPLETE;
        }
        set_new_dist = 1;
    }

    /* okay, we might need to override some dist params as well 
     * even if distribution is default parameters may be 
     * specifide in the dir hint
     */
    if (set_new_dist && pattr->u.dir.hint.dist_params_len > 0)
    {
        /* We have a series of comma separated key:val strings */
        char **key, **val;
        int64_t tmp_val;
        int nparams = 0;

        if (strncmp(current_dist->dist_name, 
                    PVFS_DIST_VARSTRIP_NAME, 
                    PVFS_DIST_VARSTRIP_NAME_SIZE) == 0) 
        {
            /* varstrip parameters are a special case; we can't use the
             * normal split_keyvals function because the : separater is also
             * used within paramers that only varstrip can parse
             */ 

            /* look for a "strips:" prefix */
            if(strstr(pattr->u.dir.hint.dist_params, "strips:") 
                != pattr->u.dir.hint.dist_params)
            {
                gossip_err("Error: failed to parse directory "
                           "hints for varstrip distribution.\n");
                js_p->error_code = -PVFS_EINVAL;
                return SM_ACTION_COMPLETE;
            }
            if(current_dist->methods->set_param(current_dist->dist_name,
                                                current_dist->params,
                                                "strips",
                &pattr->u.dir.hint.dist_params[strlen("strips:")]))
            {
                gossip_err("Error: failed to set directory "
                           "hints for varstrip distribution.\n");
                js_p->error_code = -PVFS_EINVAL;
                return SM_ACTION_COMPLETE;
            }
        }
        /* ignore parse errors! */
        /* TODO: why should we ignore parsing errors? */
        else if (PINT_split_keyvals(pattr->u.dir.hint.dist_params,
                                    &nparams, &key, &val) == 0)
        {
            int i;
            for (i = 0; i < nparams; i++)
            {
                gossip_debug(GOSSIP_CREATE_DEBUG,
                             "distribution parameter %s, value %s\n",
                             key[i], val[i]);
                /* NOTE: just as in server-config.c when parsing "Param" and
                 * "Value" fields, we will assume that all values are 64 bit
                 * integers.  The only difference here is that we scan
                 * directly into a 64 bit integer, rather than converting
                 * from the int format that dotconf supports.
                 */
                ret = sscanf(val[i], SCANF_lld, (SCANF_lld_type *)&tmp_val);
                if(ret != 1)
                {
                    gossip_err(
                        "Error: unsupported type for distribution parameter %s, "
                        "value %s found in directory hints.\n", 
                        key[i], val[i]);
                    gossip_err("Error: continuing anyway.\n");
                }
                else
                {
                    if(current_dist->methods->set_param(current_dist->dist_name,
                                                        current_dist->params,
                                                        key[i],
                                                        &tmp_val))
                    {

                        gossip_err(
                            "Error: could not override hinted distribution "
                            "parameter %s, value %s found in directory hints\n",
                            key[i], val[i]);
                    }
                 }
                 free(key[i]);
                 free(val[i]);
            }
            free(key);
            free(val);
        }
    }


    /* GET Default distribution here
     * This code is from Trunk
     * Default Dist is already accounted for in isys_create
     */
#if 0
    if (!current_dist)
    {
        /* set to default distribution */
        sm_p->u.create.dist = get_default_distribution(sm_p->parent_ref.fs_id);
        if (!sm_p->u.create.dist)
        {
            PINT_smcb_free(smcb);
            return -PVFS_ENOMEM;
        }
        current_dist = sm_p->u.create.dist;
    }
#endif

    /* Replication for metadata is always set in the configuration for
     * the file system as it is not user setable, so all we have to do is
     * grab it, but we will check and make sure it is reasonable and
     * default to 1 if not.
     * TODO There should be a reasonable max also, not implemented yet.
     */
    /*
     * We did this in PVFS2_sys_create it is already in place
     */
#if 0
    PINT_cached_config_get_metadata_sid_count(
                                sm_p->parent_ref.fs_id, 
                                &sm_p->u.create.metadata_sid_count);
    if (sm_p->u.create.metadata_sid_count <= 0)
    {
        sm_p->u.create.metadata_sid_count = 1;
    }
#endif

    /* Determining the number of dfiles.
     * priority for determining user's preference for number of data files:
     * 1) count specified in attr's passed into sys_create
     * 2) directory hints
     * 3) mount options
     * 4) system default
     * All of the above can be overridden by the distribution itself.
     */

    /* num_dfiles_requested should be 0 at this point */
    if(0 < sm_p->u.create.user_requested_num_data_files)
    {
        /* specified by sys_create caller */
        num_dfiles_requested = sm_p->u.create.user_requested_num_data_files;     
    }
    else if(0 < pattr->u.dir.hint.dfile_count)
    {
        /* taken from parent directory hints */
        num_dfiles_requested = pattr->u.dir.hint.dfile_count;
    }
    else
    {
        /* Check the mount options */
        int rc;
        struct PVFS_sys_mntent mntent;

        rc = PVFS_util_get_mntent_copy(sm_p->parent_ref.fs_id, &mntent);
        if (0 == rc)
        {
            if (0 < mntent.default_num_dfiles)
            {
                num_dfiles_requested = mntent.default_num_dfiles;
                PVFS_util_free_mntent(&mntent);
            }
        }
    }

    /* Final determination based on config and distribution.
     * Pass in the number requested by the client, but can 
     * be overridden by default configuration and/or
     * distribution if necessary.  Distribution determines
     * if there is a reasonable max or not.
     */
    ret = PINT_cached_config_get_num_dfiles(sm_p->parent_ref.fs_id,
                                            sm_p->u.create.dist,
                                            num_dfiles_requested,
                                            &sm_p->u.create.datafile_count);
    if(ret < 0)
    {
        gossip_err("Error: failed to get number of data servers\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_CREATE_DEBUG,
                 "Setting number of datafiles to %d [requested %d]\n", 
                 sm_p->u.create.datafile_count, num_dfiles_requested);

    /*
     * Set up default replication for dfiles. Again, can be set by
     * a directory hint, the configuration, or has a final default
     * of 1 (no replication).
     * TODO There should be a reasonable max also, not implemented yet.
     */

    /* check for user supplied dfile_sid_count - not implemented yet */
    /* check for directory override of dfile replication */
    if(pattr->u.dir.hint.dfile_sid_count > 0)
    {
        /* V3 not implemented yet - TODO */
        sm_p->u.create.datafile_sid_count = pattr->u.dir.hint.dfile_sid_count;
    }
    /* check for configured default datafile_sid_count */
    if(sm_p->u.create.datafile_sid_count <= 0)
    {
         PINT_cached_config_get_default_dfile_sid_count(
                                sm_p->parent_ref.fs_id, 
                                &sm_p->u.create.datafile_sid_count);
    }
    /* otherwise hard default to no replication */
    if(sm_p->u.create.datafile_sid_count <= 0)
    {
         sm_p->u.create.datafile_sid_count = 1;
    }

    return SM_ACTION_COMPLETE;
}

/*
 * setup message pair for the create request
 */
static PINT_sm_action create_create_setup_msgpair(struct PINT_smcb *smcb,
                                                  job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    PINT_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CREATE_DEBUG, "create state: "
                 "dspace_create_setup_msgpair\n");

    js_p->error_code = 0;


#if 0
    /* moved  up to init function to keep retry logic in one place. */
    /* reset the attributes to what got passed in to the sysint call. the retry
     * path comes through here so we'll want to reset it after each try. 
     * force the mask to all meta attributes. */
    if( sm_p->u.create.retry_count > 0 )
    {
        PINT_copy_object_attr(&(sm_p->u.create.attr), 
                              &(sm_p->u.create.store_attr));
        sm_p->u.create.attr.mask |= PVFS_ATTR_META_ALL;
    }
#endif

    /* This is a file create - ignore any file times passed in
     * Set them all to now.
     *
     * This represents time set by client, at least for create.  Other situations
     * time cannot be set by client because there isn't a field in req.  If we
     * are doing set by client we need to fix that.  All times by serer is another
     * option.
     */

    sm_p->u.create.attr.mask &= PVFS_ATTR_NOTIME_SET; /* clears TIME_SET bits */
    sm_p->u.create.attr.mask |= PVFS_ATTR_TIME_ALL;
    sm_p->u.create.attr.atime = sm_p->u.create.attr.ctime =
                                sm_p->u.create.attr.mtime = 
                                sm_p->u.create.attr.ntime = 
                                PINT_util_get_current_time();

#if 0
    /* creating one metadata object OID and SIDs */
    ret = PVFS_OBJ_gen_meta(&sm_p->object_ref, 1, sm_p->parent_ref.fs_id);
#endif

    gossip_debug(GOSSIP_CREATE_DEBUG,"create: Calling gen file\n");
    /* Allocate OIDs and SIDs for a file.
     * There is one OID for the metadata, and n OIDs for the data
     * and each OID has multiple SIDs.
     * We send this request to one meta server, which in turn sends it
     * to the other meta servers.
     * Data objects are not created until used.
     */
    ret = PVFS_OBJ_gen_file(sm_p->parent_ref.fs_id,
                            &sm_p->u.create.metadata_handle,
                            sm_p->u.create.metadata_sid_count, /* in */
                            &sm_p->u.create.metadata_sid_array,
                            sm_p->u.create.datafile_count,     /* in */
                            &sm_p->u.create.datafile_handles,
                            sm_p->u.create.datafile_sid_count, /* in */
                            &sm_p->u.create.datafile_sid_array);
    /* add gossip debug here to see the values created */
    if(ret != 0)
    {
        gossip_err("Failed to generate new file OID/SID\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /* object ref will now refer to newly created metadata object */
    sm_p->object_ref.handle = *sm_p->u.create.metadata_handle;
    sm_p->object_ref.fs_id = sm_p->parent_ref.fs_id;
    sm_p->object_ref.sid_count = sm_p->u.create.metadata_sid_count;
    sm_p->object_ref.sid_array = sm_p->u.create.metadata_sid_array;

    PINT_msgpair_init(&sm_p->msgarray_op);
    msg_p = &sm_p->msgarray_op.msgpair;

    /* resolve and print selected server only if gossip debugging enabled 
     * should we print more details here - OIDs and SIDs, etc.
     */
    if (gossip_debug_enabled(GOSSIP_CLIENT_DEBUG))
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, 
                     "sys_create: selected meta \n"
                     "                    OID: %s\n"
                     "                    SID: %s\n", 
                     PVFS_OID_str(&sm_p->object_ref.handle),
                     PVFS_SID_str(&sm_p->object_ref.sid_array[0]));
    }
    gossip_debug(GOSSIP_CREATE_DEBUG, "sys-create: Setting up create request\n");
    PINT_SERVREQ_CREATE_FILL(msg_p->req,
                             sm_p->getattr.attr.capability,
                             *sm_p->cred_p,
                             sm_p->u.create.attr,
                             sm_p->parent_ref.fs_id,
                             sm_p->u.create.metadata_handle, 
                             sm_p->u.create.metadata_sid_count,
                             sm_p->u.create.metadata_sid_array, 
                             &sm_p->parent_ref.handle, /* back ptr */
                             sm_p->parent_ref.sid_array, 
                             sm_p->u.create.datafile_count,
                             sm_p->u.create.datafile_handles,
                             sm_p->u.create.datafile_sid_count,
                             sm_p->u.create.datafile_sid_array,
                             sm_p->hints);

    gossip_debug(GOSSIP_CREATE_DEBUG, "sys-create: Setting up message request\n");
    msg_p->msgclass = PVFS_IO_METADATA;
    msg_p->msgdir = PVFS_IO_WRITE;
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle = *sm_p->u.create.metadata_handle;
    msg_p->sid_count = sm_p->u.create.metadata_sid_count;
    msg_p->sid_index = 0;
    msg_p->sid_array = sm_p->u.create.metadata_sid_array;
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = create_comp_fn;
    /* we are creating so we need to send attr */
    /* server will fill in object specific fields */
    msg_p->req.u.create.attr.u.meta.dist = sm_p->u.create.dist;
    msg_p->req.u.create.attr.u.meta.dist_size =
                                    PINT_DIST_PACK_SIZE(sm_p->u.create.dist);
    /* prevent encoder from trying to encode fields passed elsewhere */
    msg_p->req.u.create.attr.u.meta.dfile_count  = 0;
                                    /* sm_p->u.create.datafile_count; */
    msg_p->req.u.create.attr.u.meta.sid_count    = 0;
                                    /* sm_p->u.create.datafile_sid_count; */
    msg_p->req.u.create.attr.u.meta.size         = 0;
    msg_p->req.u.create.attr.u.meta.mirror_mode  = 0;
    /* removed during layout merge */
#if 0
    msg_p->req.u.create.attr.u.meta.stuffed      = 0;
    msg_p->req.u.create.attr.u.meta.stuffed_size = 0;
#endif

    PVFS_debug_servreq_create(GOSSIP_CREATE_DEBUG, &(msg_p->req.u.create));

    gossip_debug(GOSSIP_CREATE_DEBUG, "sys-create: Resolving address\n");
    ret = PVFS_SID_get_addr(&msg_p->svr_addr, &msg_p->sid_array[0]);
    if (ret < 0)
    {
        /* This will cause encode to fail if not resolved 
         * In current (devel) version we assume all servers are known
         * rendering this a true error - but eventually we will need to
         * have resolution code
         */
        gossip_err("PVFS_sys_create: failed to look up SID\n");
        /* V3 how to handle failure here ?
         * If we have to do a SID lookup we need to have SM block on
         * that action, or call a nested SM or something
         *
         * Should return a SM error code, call a lookup SM, then resume
         */
    }
    else
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, "sys-create target SID: %s\n",
                     PVFS_SID_str(&msg_p->sid_array[0]));
    }

    gossip_debug(GOSSIP_CREATE_DEBUG, "sys-create: Push frame\n");
    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

/*
 * set up message pair for the crdirent request
 */
static PINT_sm_action create_crdirent_setup_msgpair(struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    PINT_sm_msgpair_state *msg_p = NULL;
    PVFS_dist_dir_hash_type dirdata_hash;
    int dirdata_server_index;
    int dirdata_sid_index;
    int i;
    unsigned char *c;

    gossip_debug(GOSSIP_CREATE_DEBUG,
                 "create state: crdirent_setup_msgpair\n");

    js_p->error_code = 0;

    /* find the hash value and the dist dir bucket */
    dirdata_hash = PINT_encrypt_dirdata(sm_p->u.create.object_name);
    gossip_debug(GOSSIP_CREATE_DEBUG,
                 "create: encrypt dirent %s into hash value %llu.\n", 
                 sm_p->u.create.object_name,
                 llu(dirdata_hash));

    gossip_debug(GOSSIP_CREATE_DEBUG, "create: dist_dir_bitmap:\n");
 
    if (gossip_debug_enabled(GOSSIP_CLIENT_DEBUG))
    {
        for(i = sm_p->getattr.attr.u.dir.dist_dir_attr.bitmap_size - 1;
            i >= 0;
            i--)
        {
            c = (unsigned char *)(sm_p->getattr.attr.u.dir.dist_dir_bitmap + i);
            gossip_debug(GOSSIP_CREATE_DEBUG," i=%d : %02x %02x %02x %02x\n"
                                            , i, c[3], c[2], c[1], c[0]);
        }
        gossip_debug(GOSSIP_CREATE_DEBUG, "\n");
    }

    dirdata_server_index = 
            PINT_find_dist_dir_bucket(dirdata_hash,
                   &sm_p->getattr.attr.u.dir.dist_dir_attr,
                   sm_p->getattr.attr.u.dir.dist_dir_bitmap);

    dirdata_sid_index = dirdata_server_index *
                        sm_p->getattr.attr.u.dir.dist_dir_attr.sid_count;

    gossip_debug(GOSSIP_CREATE_DEBUG,
                 "create: selecting bucket No.%d from dist_dir_bitmap.\n", 
                 dirdata_server_index);
        
    gossip_debug(GOSSIP_CREATE_DEBUG,
                 "create: corresponding sid index is %d.\n", 
                 dirdata_sid_index);
        
    gossip_debug(GOSSIP_CREATE_DEBUG,
                 "create: %s: posting crdirent req: parent OID: %s, "
                 "name: %s, meta OID: %s\n",
                 __func__,
                 PVFS_OID_str(&sm_p->parent_ref.handle),
                 sm_p->u.create.object_name,
                 PVFS_OID_str(sm_p->u.create.metadata_handle));

    PINT_msgpair_init(&sm_p->msgarray_op);
    msg_p = &sm_p->msgarray_op.msgpair;

    /* need gossip for parent dirdata oids and sids should come from
     * earlier getattr - other items come from create data gened in
     * earlier state */

    PINT_SERVREQ_CRDIRENT_FILL(
              msg_p->req,
              sm_p->getattr.attr.capability,
              *sm_p->cred_p,
              sm_p->parent_ref.fs_id,
 /* target */ sm_p->getattr.attr.u.dir.dirdata_handles[dirdata_server_index],
              sm_p->parent_ref.sid_count,
 /* target */ &sm_p->getattr.attr.u.dir.dirdata_sids[dirdata_sid_index],
              sm_p->u.create.object_name,        /* item inserted into dir */
              *sm_p->u.create.metadata_handle,   /* item inserted into dir */
              sm_p->u.create.metadata_sid_array, /* item inserted into dir */
              sm_p->u.create.metadata_sid_count, 
              sm_p->parent_ref.handle,           /* back ptr to dir */
              sm_p->parent_ref.sid_array,        /* back ptr to dir */
              sm_p->hints);

    if (gossip_debug_enabled(GOSSIP_CLIENT_DEBUG))
    {
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): fsid(%d)\n",
                     sm_p->parent_ref.fs_id);
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): dirdata handle[%d](%s)\n",
                     dirdata_server_index,
                     PVFS_OID_str(&sm_p->getattr.attr.u.dir.dirdata_handles
                                        [dirdata_server_index]));
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): parent sid count(%d)\n",
                     sm_p->parent_ref.sid_count);
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): dirdata sid[%d](%s)\n",
                     dirdata_sid_index,
                     PVFS_SID_str(&sm_p->getattr.attr.u.dir.dirdata_sids
                                        [dirdata_sid_index]));
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): object name(%s)\n",
                     sm_p->u.create.object_name);
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): object handle(%s)\n",
                     PVFS_OID_str(sm_p->u.create.metadata_handle));
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): object sid(%s)\n",
                     PVFS_SID_str(&sm_p->u.create.metadata_sid_array[0]));
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): sid count(%d)\n",
                     sm_p->u.create.metadata_sid_count);
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): parent handle(%s)\n",
                     PVFS_OID_str(&sm_p->parent_ref.handle));
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): parent sid(%s)\n",
                     PVFS_SID_str(&sm_p->parent_ref.sid_array[0]));
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create(crdirent): msg_p->req.op(%d)\n",msg_p->req.op);
    }

    msg_p->msgclass = PVFS_IO_METADATA;
    msg_p->msgdir = PVFS_IO_WRITE;
    /* next 5 are target data for MPA */
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle =
            sm_p->getattr.attr.u.dir.dirdata_handles[dirdata_server_index];
    msg_p->sid_count = sm_p->parent_ref.sid_count;
    msg_p->sid_index = 0;
    msg_p->sid_array = 
            &sm_p->getattr.attr.u.dir.dirdata_sids[dirdata_sid_index];
    msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
    msg_p->comp_fn = create_crdirent_comp_fn;
    /* not adding an object so no attr needed */

    PVFS_debug_servreq_crdirent(GOSSIP_CREATE_DEBUG, &(msg_p->req.u.crdirent));

    ret = PVFS_SID_get_addr(&msg_p->svr_addr, &msg_p->sid_array[0]);
    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
    else
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, "sys-crdirent target SID: %s\n",
                     PVFS_SID_str(&msg_p->sid_array[0]));
    }

    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_crdirent_failure(struct PINT_smcb *smcb,
                                              job_status_s *js_p)
{
    PVFS_uid local_uid;
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    gossip_debug(GOSSIP_CREATE_DEBUG, "create state: crdirent_failure\n");

    /* if need to retry. clear the error_code and setup getattr. */
    if(js_p->error_code == -PVFS_EAGAIN &&
       sm_p->u.create.retry_count < sm_p->msgarray_op.params.retry_limit)
    {
        /* used to have a special retry thing, should now be handled by
         * MPA
         */
        sm_p->u.create.retry_count++;

        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create: received -PVFS_EAGAIN, "
                     "will retry getattr and crdirent (attempt number %d).\n",
                     sm_p->u.create.retry_count);

        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "%s:sm_p->getattr.attr.mask(0x%0lx)\n",
                     __func__,
                     sm_p->getattr.attr.mask);
        
        /* clear acache content */
        PINT_acache_invalidate(sm_p->object_ref);
        /* clear capcache content */
        local_uid = PINT_HINT_GET_LOCAL_UID(sm_p->hints);

        if (local_uid == (PVFS_uid) -1)
        {
            local_uid = PINT_util_getuid();

            PVFS_hint_add(&sm_p->hints,
                          PVFS_HINT_LOCAL_UID_NAME,
                          sizeof(PVFS_uid),
                          &local_uid);
        }

        PINT_client_capcache_invalidate(sm_p->object_ref, local_uid);

        /* set up new getattr */
        PINT_SM_GETATTR_STATE_FILL(sm_p->getattr,
                                   sm_p->object_ref,
                                   PVFS_ATTR_COMMON_ALL |
                                           PVFS_ATTR_DIR_ALL |
                                           PVFS_ATTR_DIR_HINT_ALL |
                                           PVFS_ATTR_CAPABILITY |
                                           PVFS_ATTR_DISTDIR_ATTR,
                                   PVFS_TYPE_DIRECTORY,
                                   0);
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    sm_p->u.create.stored_error_code = js_p->error_code;

    if (sm_p->u.create.stored_error_code == -PVFS_EEXIST)
    {
        gossip_debug(GOSSIP_CREATE_DEBUG, "crdirent failed: "
                     "dirent already exists!\n");
    }
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_cleanup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_size data_size = 0;
    int ret;

    gossip_debug(GOSSIP_CREATE_DEBUG, "create state: cleanup\n");

    sm_p->error_code = (sm_p->u.create.stored_error_code ?
                        sm_p->u.create.stored_error_code :
                        js_p->error_code);


    if (sm_p->error_code == 0)
    {
        /* fill in outgoing response fields */
        sm_p->u.create.create_resp->ref = sm_p->object_ref;
        sm_p->u.create.create_resp->ref.sid_array = NULL;

        sm_p->u.create.create_resp->ref.sid_array=calloc(sm_p->object_ref.sid_count,
                                                         sizeof(*sm_p->object_ref.sid_array));
        if (sm_p->u.create.create_resp->ref.sid_array == NULL)
        {
           gossip_err("%s: Error allocating memory for sid array.\n",__func__);
           js_p->error_code = -PVFS_ENOMEM;
           return SM_ACTION_COMPLETE;
        }
        memcpy(sm_p->u.create.create_resp->ref.sid_array
              ,sm_p->object_ref.sid_array
              ,sm_p->object_ref.sid_count * sizeof(*sm_p->object_ref.sid_array));


        /* V3 is this safe? we are saving a pointer to two object refs -
         * where are these allocated and freed?
         */
        /* insert newly created metafile into the ncache */
        PINT_ncache_update((const char*) sm_p->u.create.object_name, 
                           (const PVFS_object_ref *) &(sm_p->object_ref), 
                           (const PVFS_object_ref *) &(sm_p->parent_ref));

        sm_p->u.create.attr.mask |= PVFS_ATTR_META_DFILES;
        sm_p->u.create.attr.u.meta.dfile_count = sm_p->u.create.datafile_count;
        sm_p->u.create.attr.u.meta.dfile_array =
                                         sm_p->u.create.datafile_handles;
        sm_p->u.create.attr.u.meta.sid_count =
                                       sm_p->u.create.metadata_sid_count;
        sm_p->u.create.attr.u.meta.sid_array =
                                       sm_p->u.create.metadata_sid_array;

/* removed during layout merge */
#if 0
        if(sm_p->u.create.stuffed)
        {
            gossip_debug(GOSSIP_CLIENT_DEBUG, "created stuffed file\n");
            sm_p->u.create.attr.u.meta.stuffed_size = 0;
        }
        else
        {
            gossip_debug(GOSSIP_CLIENT_DEBUG, "created un-stuffed file\n");
            sm_p->u.create.attr.mask |= PVFS_ATTR_META_UNSTUFFED;
        }
#endif

        if(sm_p->u.create.dist)
        {
            sm_p->u.create.attr.u.meta.dist = sm_p->u.create.dist;
            sm_p->u.create.attr.u.meta.dist_size =
                            PINT_DIST_PACK_SIZE(sm_p->u.create.dist);
            sm_p->u.create.attr.mask |= PVFS_ATTR_META_DIST;
        }

        /* we only insert a cache entry if the entire create succeeds,
         * set size to 0 
         * we know that the file size is zero, since we just created it. 
         */ 
        ret = PINT_acache_update(sm_p->object_ref,
                                 &sm_p->u.create.attr,
                                 &data_size);
        if(ret < 0)
        {
            js_p->error_code = ret;
        }

        /* invalidate the acache entry for the parent directory,
         * because we created a new directory entry which
         * changes the timestamps on the directory.
         */
        PINT_acache_invalidate(sm_p->parent_ref);

    }
    else if ((PVFS_ERROR_CLASS(-sm_p->error_code) == PVFS_ERROR_BMI) &&
             (sm_p->u.create.retry_count <
              sm_p->msgarray_op.params.retry_limit))
    {
        sm_p->u.create.stored_error_code = 0;
        sm_p->u.create.retry_count++;

        gossip_debug(GOSSIP_CREATE_DEBUG, "Retrying create operation "
                     "(attempt number %d)\n", sm_p->u.create.retry_count);

        js_p->error_code = CREATE_RETRY;
        return SM_ACTION_COMPLETE;
    }

    if(sm_p->u.create.layout.algorithm == PVFS_SYS_LAYOUT_LIST)
    {
        free(sm_p->u.create.layout.server_list.servers);
        sm_p->u.create.layout.server_list.servers = NULL;
    }

    if(sm_p->u.create.dist)
    {
        PINT_dist_free(sm_p->u.create.dist);
        sm_p->u.create.dist = NULL;
    }

    if(sm_p->u.create.metadata_handle)
    {
        free(sm_p->u.create.metadata_handle);
        sm_p->u.create.metadata_handle = NULL;
    }

    if(sm_p->u.create.metadata_sid_array)
    {
        free(sm_p->u.create.metadata_sid_array);
        sm_p->u.create.metadata_sid_array = NULL;
    }

    if(sm_p->u.create.datafile_handles)
    {
        free(sm_p->u.create.datafile_handles);
        sm_p->u.create.datafile_handles = NULL;
    }

    if(sm_p->u.create.datafile_sid_array)
    {
        free(sm_p->u.create.datafile_sid_array);
        sm_p->u.create.datafile_sid_array = NULL;
    }

    if(sm_p->u.create.dirent_handle)
    {
        free(sm_p->u.create.dirent_handle);
        sm_p->u.create.dirent_handle = NULL;
    }

    if(sm_p->u.create.dirent_sid_array)
    {
        free(sm_p->u.create.dirent_sid_array);
        sm_p->u.create.dirent_sid_array = NULL;
    }

    PINT_free_object_attr(&sm_p->u.create.store_attr);

    PINT_msgpairarray_destroy(&sm_p->msgarray_op);

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}

/** HELPER FUNCTION
 * Returns the default distribution, or NULL if the distribution could not
 * be created.  The default distribution is read from the server
 * configuration if possible.  If the server config does not specify a
 * default distribution, simple_stripe will be used.
 */
static PINT_dist *get_default_distribution(PVFS_fs_id fs_id)
{
    server_configuration_t *server_config = NULL;
    PINT_dist *dist = NULL;

    /* Retrieve the server configuration (with mutex) */
    server_config = PINT_get_server_config_struct(fs_id);

    /* If a default dist is specified in the config, use that
       else just create a simple_stripe distribution */
    if (server_config == NULL ||
        server_config->default_dist_config.name == NULL )
    {
        /* we have already set up simple stripe default so skip this */
#if 0
        dist = PINT_dist_create(PVFS_DIST_SIMPLE_STRIPE_NAME);
#endif
        goto getdist_exit;
    }
    /* We should probably make sure the default params are set 
     * either here or when the default is set up
     */
    
    /* this allocates a packed memory space with the PINT_dist strucct,
     * name string and distribution specific parameters.
     */
    dist = PINT_dist_create(server_config->default_dist_config.name);
    
    if (!dist)
    {
        gossip_err("Error creating default distribution: %s\n",
                   server_config->default_dist_config.name);
        goto getdist_exit;
    }

    /* parameters are sent in with a list but actually live in an
     * array in the PINT_dist struct
     */
    PINT_llist_p iter = server_config->default_dist_config.param_list;

    /* Iterate through the supplied distribution parameters */
    while (iter)
    {
        int rc;
        distribution_param_config_t *param = PINT_llist_head(iter);

        /* If we are at the list end, break
           else, set the distribution parameter to the given value */
        if (param == NULL)
        {
            break;
        }
        rc = dist->methods->set_param(dist->dist_name,
                                      dist->params,
                                      param->name,
                                      &param->value);

        if (rc != 0)
        {
            gossip_err("Error setting distribution parameter\n"
                       "  dist: %s\n"
                       "  param name: %s\n"
                       "  param value: %lld\n",
                       dist->dist_name, param->name,
                       lld(param->value));
        }
        iter = PINT_llist_next(iter);
    }                

getdist_exit:

    /* Release the server config mutex */
    PINT_put_server_config_struct(server_config);

    return dist;
}

/* delete the newly created meta and data handles */
static PINT_sm_action create_delete_handles_setup_msgpair_array(
                                 struct PINT_smcb *smcb,
                                 job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL, i = 0;
    PINT_sm_msgpair_state *msg_p = NULL;
    int dfilesids = 0;

    gossip_debug(GOSSIP_CREATE_DEBUG, "create state: "
                 "delete_handles_setup_msgpair_array\n");

    js_p->error_code = 0;

    ret = PINT_msgpairarray_init(&sm_p->msgarray_op,
                                 (sm_p->u.create.datafile_count + 1));
    if(ret != 0)
    {
        gossip_err("Failed to initialize %d msgpairs\n",
                   (sm_p->u.create.datafile_count+1));
        js_p->error_code = ret;
        return(SM_ACTION_COMPLETE);
    }

    /*
     * for the metafile and each datafile, prepare to post a remove
     * send/recv pair
     */
    dfilesids = sm_p->u.create.datafile_sid_count;
    foreach_msgpair(&sm_p->msgarray_op, msg_p, i)
    {
        gossip_debug(GOSSIP_CREATE_DEBUG,
                     "create: posting data file remove req %d\n", i);

        /* arbitrarily handle deletion of the metafile last */
        if (i == sm_p->u.create.datafile_count)
        {
            PINT_SERVREQ_REMOVE_FILL(msg_p->req,
                                     sm_p->getattr.attr.capability,
                                     *sm_p->cred_p,
                                     sm_p->object_ref.fs_id,
                                     sm_p->object_ref.handle,
                                     sm_p->object_ref.sid_count,
                                     sm_p->object_ref.sid_array,
                                     sm_p->hints);

            msg_p->msgclass = PVFS_IO_METADATA;
            msg_p->msgdir = PVFS_IO_WRITE;
            msg_p->fs_id = sm_p->object_ref.fs_id;
            msg_p->handle = sm_p->object_ref.handle;
            msg_p->sid_count = sm_p->object_ref.sid_count;
            msg_p->sid_index = 0;
            msg_p->sid_array = sm_p->object_ref.sid_array;
            msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
            msg_p->comp_fn = create_delete_handles_comp_fn;
            PVFS_SID_get_addr(&msg_p->svr_addr, &msg_p->sid_array[0]);

            gossip_debug(GOSSIP_CREATE_DEBUG, " Preparing to remove "
                         "metafile handle %s\n", PVFS_OID_str(&msg_p->handle));
        }
        else
        {
            PINT_SERVREQ_REMOVE_FILL(msg_p->req,
                                     sm_p->getattr.attr.capability,
                                     *sm_p->cred_p,
                                     sm_p->object_ref.fs_id,
                                     sm_p->u.create.datafile_handles[i],
                                     dfilesids,
                                     &sm_p->u.create.datafile_sid_array[
                                                               i * dfilesids], 
                                     sm_p->hints);

            msg_p->msgclass = PVFS_IO_METADATA;
            msg_p->msgdir = PVFS_IO_WRITE;
            msg_p->fs_id = sm_p->object_ref.fs_id;
            msg_p->handle = sm_p->u.create.datafile_handles[i];
            msg_p->sid_count = dfilesids;
            msg_p->sid_index = 0;
            msg_p->sid_array = &sm_p->u.create.metadata_sid_array[
                                                            i * dfilesids];
            msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
            msg_p->comp_fn = create_delete_handles_comp_fn;
            PVFS_SID_get_addr(&msg_p->svr_addr,
                              &msg_p->sid_array[i * dfilesids]); 

            gossip_debug(GOSSIP_CREATE_DEBUG, " Preparing to remove "
                         "datafile handle %s\n", PVFS_OID_str(&msg_p->handle));
        }
    }

    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
